# Router设计
*   路由注册(核心，不对外暴露)
    *   注册时机
        *   在项目启动时（服务运行前）统一注册，启动完成后不能再进行注册
    *   注册执行者
        *   HttpServer
    *   注册路由的扩展，对外提供扩展接口
        *   GET
        *   POST
        *   DELETE
        *   PUT
           
*   路由的存储
    *   方案一
        *   在HttpServer中使用map进行存储
            *   格式：map[method-pattern]HandleFunc
        *   缺点
            *   不能匹配带参数的路由
    *   方案二
        *   方案一的基础上加入前缀树来优化存储
*   路由冲突
    *   /login & /login
    *   /reg/:pd & /reg/:wk
    *   /study/:course & /study/*file & /study/login

*   路由的顺序
    *   插入
        *   通配符路由
            *   有参数路由，不进行插入
        *   参数路由
            *   有通配符路由，则不能插入
            *   有不同名称的参数路由，也不能插入
        *   静态路由
            *   存在同名路由，不做覆盖，插入失败
    *   搜索
        *   静态路由
            *   优先级最高
        *   参数路由
            *   静态路由找不到，再尝试匹配参数路由
        *   通配符路由
            *   静态路由和参数路由节点都找不到，返回通配符路由,
                *   通配符路由存在 =》匹配成功
                *   通配符路由不存在 =》 匹配失败    


*   路由的运行
    *   由ServeHTTP拦截用户请求，转发到对应路由
    *   过程
        *   接收请求
        *   匹配路由
            *   匹配失败：对响应头写入http.StatusNotFound
*   路由优先级
    *   静态路由
    *   动态路由(含参)
        *   参数路由：addr:port/login/:username/:pwd/
        *   通配符路由：addr:port/static/*filepath
*   前缀树理解
    *   共用相同的部分，只区分不同的部分，节省存储重复部分的空间
    *   例如：abcde,abcdf
        *   两者前面的前缀"abcd"相同,可以只保存一份

*   路由组（分组控制）
    *   作用
        *   可以实现分版本注册路由
    *   一般结构
        ```go
        /*
            gin
        */
        type RouterGroup struct {

            // 路由组前缀（路由组的唯一标识）
            prefix string

            // 路由组的上级路由组（路由组的嵌套）
            parent *RouterGroup

            //
            engine *Server

            // 中间件处理
            ...
        }
        ```
    *   总结
        *   Group方法返回一个RouterGroup对象
        *   Engine和RouterGroup在某些方法上是一样的，可以认为是“一个东西”
            *   可以让二者进行嵌套，存在父子关系，使得子对象可以使用父对象的方法
            *   相同的方法放在哪个对象？